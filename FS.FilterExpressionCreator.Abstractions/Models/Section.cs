using System;
using System.Collections.Generic;

namespace FS.FilterExpressionCreator.Abstractions.Models
{
    /// <summary>
    /// Represents a section of <typeparamref name="TType"/>.
    /// </summary>
    public class Section<TType> : IEquatable<Section<TType>>, IConvertible where TType : IComparable<TType>
    {
        /// <summary>
        /// The start of section.
        /// </summary>
        public TType Start { get; }

        /// <summary>
        /// The end of section.
        /// </summary>
        public TType End { get; }

        /// <summary>
        /// Gets the distance between <see cref="Start"/> and <see cref="End"/>.
        /// </summary>
        /// <autogeneratedoc />
        public double Distance => ToDouble(End) - ToDouble(Start);

        /// <summary>
        /// Initializes a new instance of the <see cref="Section{TType}"/> class.
        /// </summary>
        /// <param name="start">The start of section.</param>
        /// <param name="end">The end of section.</param>
        public Section(TType start, TType end)
        {
            Start = start;
            End = end;
        }

        /// <inheritdoc />
        public override string ToString()
        {
            var start = ToString(Start);
            var end = ToString(End);

            if (start != null && end != null)
                return $"{start}_{end}";
            if (start != null)
                return start;
            if (end != null)
                return end;
            return string.Empty;
        }

        /// <inheritdoc />
        public override bool Equals(object obj)
            => Equals(obj as Section<TType>);

        /// <inheritdoc />
        public bool Equals(Section<TType> other)
            => other != null && EqualityComparer<TType>.Default.Equals(Start, other.Start) && EqualityComparer<TType>.Default.Equals(End, other.End);

        /// <inheritdoc />
        public override int GetHashCode()
            => HashCode.Combine(Start, End);

        /// <summary>
        /// Indicates whether the <paramref name="val1"/> object is equal to <paramref name="val2"/> object.
        /// </summary>
        /// <param name="val1">The object to compare with <paramref name="val2"/>.</param>
        /// <param name="val2">The object to compare with <paramref name="val1"/>.</param>
        public static bool operator ==(Section<TType> val1, Section<TType> val2)
            => EqualityComparer<Section<TType>>.Default.Equals(val1, val2);

        /// <summary>
        /// Indicates whether the <paramref name="val1"/> object is not equal to <paramref name="val2"/> object.
        /// </summary>
        /// <param name="val1">The object to compare with <paramref name="val2"/>.</param>
        /// <param name="val2">The object to compare with <paramref name="val1"/>.</param>
        public static bool operator !=(Section<TType> val1, Section<TType> val2)
            => !(val1 == val2);

        /// <summary>
        /// Indicates whether the section of <paramref name="val1"/> is lower than the section of <paramref name="val2"/> object.
        /// </summary>
        /// <param name="val1">The object to compare with <paramref name="val2"/>.</param>
        /// <param name="val2">The object to compare with <paramref name="val1"/>.</param>
        public static bool operator <(Section<TType> val1, Section<TType> val2)
            => ((IConvertible)val1).ToDecimal(null) < ((IConvertible)val2).ToDecimal(null);

        /// <summary>
        /// Indicates whether the section of <paramref name="val1"/> is greater than the section of <paramref name="val2"/> object.
        /// </summary>
        /// <param name="val1">The object to compare with <paramref name="val2"/>.</param>
        /// <param name="val2">The object to compare with <paramref name="val1"/>.</param>
        public static bool operator >(Section<TType> val1, Section<TType> val2)
            => ((IConvertible)val1).ToDecimal(null) > ((IConvertible)val2).ToDecimal(null);

        /// <summary>
        /// Indicates whether the section of <paramref name="val1"/> is lower than or equal to the section of <paramref name="val2"/> object.
        /// </summary>
        /// <param name="val1">The object to compare with <paramref name="val2"/>.</param>
        /// <param name="val2">The object to compare with <paramref name="val1"/>.</param>
        public static bool operator <=(Section<TType> val1, Section<TType> val2)
            => ((IConvertible)val1).ToDecimal(null) <= ((IConvertible)val2).ToDecimal(null);

        /// <summary>
        /// Indicates whether the section of <paramref name="val1"/> is greater than or equal to the section of <paramref name="val2"/> object.
        /// </summary>
        /// <param name="val1">The object to compare with <paramref name="val2"/>.</param>
        /// <param name="val2">The object to compare with <paramref name="val1"/>.</param>
        public static bool operator >=(Section<TType> val1, Section<TType> val2)
            => ((IConvertible)val1).ToDecimal(null) >= ((IConvertible)val2).ToDecimal(null);

        /// <summary>
        /// Checks if two <typeparamref name="TType"/> intersects with each other.
        /// </summary>
        /// <param name="val1">The first of two <see cref="DateTimeOffset"/> to compare.</param>
        /// <param name="val2">The second of two <see cref="DateTimeOffset"/> to compare.</param>
        public static bool Intersect(Section<TType> val1, Section<TType> val2)
        {
            var val1StartIsLowerThanVal2End = val1.Start.CompareTo(val2.End) <= 0;
            var val2StartIsLowerThanVal1End = val2.Start.CompareTo(val1.End) <= 0;
            return val1StartIsLowerThanVal2End && val2StartIsLowerThanVal1End;
        }

        /// <summary>
        /// Checks if a second <typeparamref name="TType"/> intersects with this one.
        /// </summary>
        /// <param name="other">The <typeparamref name="TType"/> to check intersection with.</param>
        public bool Intersect(Section<TType> other)
            => Intersect(this, other);

        /// <summary>
        /// Returns the intersected section of two <typeparamref name="TType"/>.
        /// </summary>
        /// <param name="val1">The first of two <see cref="DateTimeOffset"/> to compare.</param>
        /// <param name="val2">The second of two <see cref="DateTimeOffset"/> to compare.</param>
        public static Section<TType> Intersection(Section<TType> val1, Section<TType> val2)
        {
            if (!Intersect(val1, val2))
                return default;

            var start = Max(val1.Start, val2.Start);
            var end = Min(val1.End, val2.End);
            return new Section<TType>(start, end);
        }

        /// <summary>
        /// Returns the intersected section of this and a second <typeparamref name="TType"/>.
        /// </summary>
        /// <param name="other">The <typeparamref name="TType"/> to check intersection with.</param>
        public Section<TType> Intersection(Section<TType> other)
            => Intersection(this, other);

        /// <summary>
        /// Determines whether this instance contains the <paramref name="other"/>.
        /// </summary>
        /// <param name="other">The <typeparamref name="TType"/> to check containment with.</param>
        public bool Contains(Section<TType> other)
        {
            var thisStartIsLowerThanRhsStart = Start.CompareTo(other.Start) <= 0;
            var thisEndIsGreaterThanRhsEnd = End.CompareTo(other.End) >= 0;
            return thisStartIsLowerThanRhsStart && thisEndIsGreaterThanRhsEnd;
        }

        private static string ToString(TType value)
            => value switch
            {
                null => null,
                DateTime dateTime => dateTime.ToString("o"),
                DateTimeOffset dateTime => dateTime.ToString("o"),
                _ => value.ToString()
            };

        private static double ToDouble(TType val)
            => val switch
            {
                null => 0,
                DateTime dateTime => dateTime.Ticks,
                DateTimeOffset dateTime => dateTime.Ticks,
                IConvertible convertible => convertible.ToDouble(null),
                _ => throw new InvalidOperationException($"The type {typeof(TType).Name} is not convertible to {nameof(Double)}"),
            };

        /// <summary>
        /// Returns the lower of two <typeparamref name="TType"/>.
        /// </summary>
        /// <param name="val1">The first of two <typeparamref name="TType"/> to compare.</param>
        /// <param name="val2">The second of two <typeparamref name="TType"/> to compare.</param>
        private static TType Min(TType val1, TType val2)
            => val1.CompareTo(val2) <= 0 ? val1 : val2;

        /// <summary>
        /// Returns the greater of two <typeparamref name="TType"/>.
        /// </summary>
        /// <param name="val1">The first of two <typeparamref name="TType"/> to compare.</param>
        /// <param name="val2">The second of two <typeparamref name="TType"/> to compare.</param>
        private static TType Max(TType val1, TType val2)
            => val1.CompareTo(val2) >= 0 ? val1 : val2;

        #region IConvertible
        TypeCode IConvertible.GetTypeCode()
            => TypeCode.Object;

        bool IConvertible.ToBoolean(IFormatProvider provider)
            => throw new InvalidCastException($"Invalid cast from {nameof(Section)} to {nameof(Boolean)}");

        char IConvertible.ToChar(IFormatProvider provider)
            => throw new InvalidCastException($"Invalid cast from {nameof(Section)} to {nameof(Char)}");

        DateTime IConvertible.ToDateTime(IFormatProvider provider)
            => throw new InvalidCastException($"Invalid cast from {nameof(Section)} to {nameof(DateTime)}");

        string IConvertible.ToString(IFormatProvider provider)
            => this.ToString();

        object IConvertible.ToType(Type conversionType, IFormatProvider provider)
        {
            try
            {
                return ((IConvertible)((IConvertible)this).ToDouble(provider)).ToType(conversionType, provider);
            }
            catch (OverflowException)
            {
                throw new OverflowException($"Section was too large for a {conversionType.Name}");
            }
        }

        byte IConvertible.ToByte(IFormatProvider provider)
        {
            var result = ToDouble(End) - ToDouble(Start);
            if (result <= byte.MaxValue)
                return (byte)result;
            throw new OverflowException($"Section was too large for a {nameof(Byte)}");
        }

        decimal IConvertible.ToDecimal(IFormatProvider provider)
        {
            try
            {
                return Convert.ToDecimal(ToDouble(End) - ToDouble(Start));
            }
            catch (OverflowException)
            {
                throw new OverflowException($"Section was too large for a {nameof(Decimal)}");
            }
        }

        double IConvertible.ToDouble(IFormatProvider provider)
            => ToDouble(End) - ToDouble(Start);

        short IConvertible.ToInt16(IFormatProvider provider)
        {
            var result = ToDouble(End) - ToDouble(Start);
            if (result <= short.MaxValue)
                return (short)result;
            throw new OverflowException($"Section was too large for a {nameof(Int16)}");
        }

        int IConvertible.ToInt32(IFormatProvider provider)
        {
            var result = ToDouble(End) - ToDouble(Start);
            if (result <= int.MaxValue)
                return (int)result;
            throw new OverflowException($"Section was too large for a {nameof(Int32)}");
        }

        long IConvertible.ToInt64(IFormatProvider provider)
        {
            var result = ToDouble(End) - ToDouble(Start);
            if (result <= long.MaxValue)
                return (long)result;
            throw new OverflowException($"Section was too large for a {nameof(Int64)}");
        }

        sbyte IConvertible.ToSByte(IFormatProvider provider)
        {
            var result = ToDouble(End) - ToDouble(Start);
            if (result <= sbyte.MaxValue)
                return (sbyte)result;
            throw new OverflowException($"Section was too large for a {nameof(SByte)}");
        }

        float IConvertible.ToSingle(IFormatProvider provider)
        {
            var result = ToDouble(End) - ToDouble(Start);
            if (result < float.MaxValue)
                return (float)result;
            throw new OverflowException($"Section was too large for a {nameof(Single)}");
        }

        ushort IConvertible.ToUInt16(IFormatProvider provider)
        {
            var result = ToDouble(End) - ToDouble(Start);
            if (result <= ushort.MaxValue)
                return (ushort)result;
            throw new OverflowException($"Section was too large for a {nameof(UInt16)}");
        }

        uint IConvertible.ToUInt32(IFormatProvider provider)
        {
            var result = ToDouble(End) - ToDouble(Start);
            if (result <= uint.MaxValue)
                return (uint)result;
            throw new OverflowException($"Section was too large for a {nameof(UInt32)}");
        }

        ulong IConvertible.ToUInt64(IFormatProvider provider)
        {
            var result = ToDouble(End) - ToDouble(Start);
            if (result <= ulong.MaxValue)
                return (ulong)result;
            throw new OverflowException($"Section was too large for a {nameof(UInt64)}");
        }
        #endregion
    }

    /// <summary>
    /// Utility class to create a <see cref="Section{TType}"/>.
    /// </summary>
    public static class Section
    {
        /// <summary>
        /// Creates a <see cref="Section{TType}"/>.
        /// </summary>
        /// <typeparam name="TType">The type of the values represented by section.</typeparam>
        /// <param name="start">The start of section.</param>
        /// <param name="end">The end of section.</param>
        public static Section<TType> Create<TType>(TType start, TType end) where TType : IComparable<TType>
            => new Section<TType>(start, end);
    }
}